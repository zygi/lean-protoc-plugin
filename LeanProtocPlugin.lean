import LeanProtocPlugin.google.protobuf.compiler.plugin
import LeanProtocPlugin.google.protobuf.descriptor

import LeanProto
import LeanProtocPlugin.Helpers
import LeanProtocPlugin.ProtoGenM
import LeanProtocPlugin.Logic

import Lean.Elab.Term
import Lean.Hygiene
import Init.System.IO
import Std.Data.RBTree
import Std.Data.RBMap

open google.protobuf.compiler
open google.protobuf
open IO (FS.Stream)

open Lean
open Lean.Elab.Term

-- deriving instance Inhabited for Std.RBMap

def defaultImports (sourceFilename: String) : Array String := #[
  "-- Generated by the Lean protobuf compiler. Do not edit manually.",
  s!"-- source: {sourceFilename}",
  "",
  "import LeanProto",
  "import Std.Data.AssocList",
  "import Lean.Elab.Deriving.InhabitedMut"
]

def defaultSettings : Array String := #[
  "set_option maxHeartbeats 10000000",
  "set_option genSizeOfSpec false"
]

def addImportDeps (f: FileDescriptorProto): ProtoGenM Unit := do
  let namespacePrefix := (← read).namespacePrefix
  let paths := f.dependency.map (filePathToPackage ∘ fun s => namespacePrefix ++ "." ++ s)
  let importCommands ← paths.mapM (s!"import {·}")
  addLines importCommands

-- Build context
structure ContextPrepState where
  enums : Array (String × (ASTPath × EnumDescriptorProto)) := #[]
  oneofs : Array (String × (ASTPath × OneofDescriptorProto)) := #[]
  messages : Array (String × ASTPath) := #[]
  deriving Inhabited, Repr

def prepareContextRecurseFile (d: ASTPath) (_: Unit): StateM ContextPrepState Unit := do
  let mut s ← get
  let extraS : ContextPrepState := match d.revMessages.head? with 
  | some m => {
    enums := m.enumType.map (fun e => (d.protoFullPath ++ "." ++ e.name.get!, (d, e))),
    oneofs := m.oneofDecl.map (fun e => (d.protoFullPath ++ "." ++ e.name.get!, (d, e))),
    messages := #[(d.protoFullPath, d)]
    }
  | none => {
    enums := d.file.enumType.map (fun e => (d.protoFullPath ++ "." ++ e.name.get!, (d, e))),
  }

  set { 
    enums := s.enums ++ extraS.enums, 
    oneofs := s.oneofs ++ extraS.oneofs, 
    messages := s.messages ++ extraS.messages
    : ContextPrepState}

def prepareContext (r: compiler.CodeGeneratorRequest) : ContextPrepState :=   
  let rec doWork (f: FileDescriptorProto) : StateM ContextPrepState PUnit := do
    recurseM ((ASTPath.init f), ()) (wrapRecurseFn prepareContextRecurseFile)
  let doWorkM := r.protoFile.forM $ doWork
  StateT.run doWorkM {} |> Id.run |> Prod.snd

def doWork (file: FileDescriptorProto) : ProtoGenM CodeGeneratorResponse_File := do
  let contextAux ← read
  for e in contextAux.messageDescriptorMap do
    -- for f in e.fst do
    IO.eprintln s!"{e.fst} {← messageFullLeanPath e.snd}"

  for e in contextAux.enumDescriptorMap do
    -- for f in e.fst do
    IO.eprintln s!"{e.fst} {← enumFullLeanPath e.snd}"

  addLines $ defaultImports file.name.get!
  addImportDeps file
  addLine ""
  addLines $ defaultSettings
  addLine ""

  generateEnumDeclarations file

  addLines #["", "mutual", ""]
  generateMessageDeclarations file
  addLines #["", "end", ""]

  generateMessageManualDerives file


  addLines #["", "mutual", ""]
  generateDeserializers file
  addLines #["", "end", ""]

  return CodeGeneratorResponse_File.mk (protoFilePathToLeanFilePath file.name.get!) none ("\n".intercalate (← get).lines.toList) none

def main(argv: List String): IO UInt32 := do
  let i ← IO.getStdin
  let o ← IO.getStdout
  
  let bytes ← i.readBinToEnd
  let request ← Except.unwrap $ LeanProto.ProtoDeserialize.deserialize (α:=CodeGeneratorRequest) bytes

  let namespacePrefix := request.parameter.get!

  let filesToWrite := rbtreeOfC request.fileToGenerate
  let fileProtos := rbmapOfC (request.protoFile.map fun x => (x.name.get!, x))
  let fileProtosToWrite := request.protoFile.filter fun v => filesToWrite.contains v.name.get!

  let contextAux := prepareContext request
  let ctxForFile (f: FileDescriptorProto) := ProtoGenContext.mk namespacePrefix fileProtos f
    (rbmapOfC contextAux.enums)
    (rbmapOfC contextAux.oneofs)
    (rbmapOfC contextAux.messages)

  let processFile (f: FileDescriptorProto) : IO CodeGeneratorResponse_File :=
    StateT.run' (ReaderT.run (doWork f) (ctxForFile f)) {}  

  let response : CodeGeneratorResponse ← do try
    let processed : Array CodeGeneratorResponse_File ← fileProtosToWrite.mapM processFile
    CodeGeneratorResponse.mk none none processed
  catch e: IO.Error =>
    CodeGeneratorResponse.mk (some e.toString) none #[]  

  o.write $ LeanProto.ProtoSerialize.serialize response

  return 0