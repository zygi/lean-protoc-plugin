-- Generated by the Lean protobuf compiler. Do not edit manually.
-- source: google/protobuf/compiler/plugin.proto

import LeanProto
import Std.Data.AssocList
import Lean.Elab.Deriving.InhabitedMut
import LeanProtocPlugin.google.protobuf.descriptor

open Std
open google.protobuf

set_option maxHeartbeats 10000000
set_option genSizeOfSpec false
namespace google
namespace protobuf
namespace compiler



inductive CodeGeneratorResponse_Feature where
| FEATURE_NONE : CodeGeneratorResponse_Feature
| FEATURE_PROTO3_OPTIONAL : CodeGeneratorResponse_Feature
deriving Inhabited, BEq, Repr

instance : LeanProto.ProtoEnum CodeGeneratorResponse_Feature where
  toInt
  | CodeGeneratorResponse_Feature.FEATURE_NONE => 0
  | CodeGeneratorResponse_Feature.FEATURE_PROTO3_OPTIONAL => 1

  ofInt
  | 0 => CodeGeneratorResponse_Feature.FEATURE_NONE
  | 1 => CodeGeneratorResponse_Feature.FEATURE_PROTO3_OPTIONAL
  | _ => none




#eval "Starting..."

mutual
inductive Version where
| mk
  (major : (Option (Int)))
  (minor : (Option (Int)))
  (patch : (Option (Int)))
  (suffix : (Option (String)))
    : Version

inductive CodeGeneratorRequest where
| mk
  (fileToGenerate : (Array (String)))
  (parameter : (Option (String)))
  (protoFile : (Array (google.protobuf.FileDescriptorProto)))
  (compilerVersion : (Option (Version)))
    : CodeGeneratorRequest

inductive CodeGeneratorResponse_File where
| mk
  (name : (Option (String)))
  (insertionPoint : (Option (String)))
  (content : (Option (String)))
  (generatedCodeInfo : (Option (google.protobuf.GeneratedCodeInfo)))
    : CodeGeneratorResponse_File

inductive CodeGeneratorResponse where
| mk
  (error : (Option (String)))
  (supportedFeatures : (Option (Nat)))
  (file : (Array (CodeGeneratorResponse_File)))
    : CodeGeneratorResponse

end

#eval "Defined definitions"

deriving instance BEq for Version, CodeGeneratorRequest, CodeGeneratorResponse_File, CodeGeneratorResponse
deriving instance InhabitedMut for Version, CodeGeneratorRequest, CodeGeneratorResponse_File, CodeGeneratorResponse
deriving instance Repr for Version, CodeGeneratorRequest, CodeGeneratorResponse_File, CodeGeneratorResponse
#eval "Defined deriving"

def Version.major : Version -> (Option (Int))
| mk v _ _ _ => v
def Version.minor : Version -> (Option (Int))
| mk _ v _ _ => v
def Version.patch : Version -> (Option (Int))
| mk _ _ v _ => v
def Version.suffix : Version -> (Option (String))
| mk _ _ _ v => v
def Version.mkDefault : Version := Inhabited.default

def CodeGeneratorRequest.fileToGenerate : CodeGeneratorRequest -> (Array (String))
| mk v _ _ _ => v
def CodeGeneratorRequest.parameter : CodeGeneratorRequest -> (Option (String))
| mk _ v _ _ => v
def CodeGeneratorRequest.protoFile : CodeGeneratorRequest -> (Array (google.protobuf.FileDescriptorProto))
| mk _ _ v _ => v
def CodeGeneratorRequest.compilerVersion : CodeGeneratorRequest -> (Option (Version))
| mk _ _ _ v => v
def CodeGeneratorRequest.mkDefault : CodeGeneratorRequest := Inhabited.default

def CodeGeneratorResponse.error : CodeGeneratorResponse -> (Option (String))
| mk v _ _ => v
def CodeGeneratorResponse.supportedFeatures : CodeGeneratorResponse -> (Option (Nat))
| mk _ v _ => v
def CodeGeneratorResponse.file : CodeGeneratorResponse -> (Array (CodeGeneratorResponse_File))
| mk _ _ v => v
def CodeGeneratorResponse.mkDefault : CodeGeneratorResponse := Inhabited.default

def CodeGeneratorResponse_File.name : CodeGeneratorResponse_File -> (Option (String))
| mk v _ _ _ => v
def CodeGeneratorResponse_File.insertionPoint : CodeGeneratorResponse_File -> (Option (String))
| mk _ v _ _ => v
def CodeGeneratorResponse_File.content : CodeGeneratorResponse_File -> (Option (String))
| mk _ _ v _ => v
def CodeGeneratorResponse_File.generatedCodeInfo : CodeGeneratorResponse_File -> (Option (google.protobuf.GeneratedCodeInfo))
| mk _ _ _ v => v
def CodeGeneratorResponse_File.mkDefault : CodeGeneratorResponse_File := Inhabited.default

#eval "Defined accessors"

mutual
partial def Version__serializeAux (x: ByteArray) : Version -> ByteArray
| Version.mk a0 a1 a2 a3 => do
  let mut res : ByteArray := Inhabited.default
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeIntAsInt32) 0 rfl 1) res a0
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeIntAsInt32) 0 rfl 2) res a1
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeIntAsInt32) 0 rfl 3) res a2
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeString) 2 rfl 4) res a3
  return res


partial def Version__deserializeAux (x: Version) : LeanProto.EncDec.ProtoParseM Version := do
  if (← LeanProto.EncDec.done) then return x
  let (typ, key) ← LeanProto.EncDec.decodeKey
  match key with
  | 1 => do Version__deserializeAux (Version.mk ((← (LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeInt32AsInt) (x.major.getD arbitrary))) (Version.minor x) (Version.patch x) (Version.suffix x) )
  | 2 => do Version__deserializeAux (Version.mk (Version.major x) ((← (LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeInt32AsInt) (x.minor.getD arbitrary))) (Version.patch x) (Version.suffix x) )
  | 3 => do Version__deserializeAux (Version.mk (Version.major x) (Version.minor x) ((← (LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeInt32AsInt) (x.patch.getD arbitrary))) (Version.suffix x) )
  | 4 => do Version__deserializeAux (Version.mk (Version.major x) (Version.minor x) (Version.patch x) ((← (LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeString) (x.suffix.getD arbitrary))) )
  | _ => do if (← LeanProto.EncDec.done) then throw $ IO.userError "EoF before unknown value"
            Version__deserializeAux x


partial def CodeGeneratorRequest__serializeAux (x: ByteArray) : CodeGeneratorRequest -> ByteArray
| CodeGeneratorRequest.mk a0 a1 a2 a3 => do
  let mut res : ByteArray := Inhabited.default
  res := LeanProto.EncDec.encodeUnpackedArrayWithTag (LeanProto.EncDec.encodeString) 2 rfl 1 res a0
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeString) 2 rfl 2) res a1
  res := LeanProto.EncDec.encodeUnpackedArrayWithTag (LeanProto.EncDec.encodeMessage (google.protobuf.FileDescriptorProto__serializeAux)) 2 rfl 15 res a2
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeMessage (Version__serializeAux)) 2 rfl 3) res a3
  return res


partial def CodeGeneratorRequest__deserializeAux (x: CodeGeneratorRequest) : LeanProto.EncDec.ProtoParseM CodeGeneratorRequest := do
  if (← LeanProto.EncDec.done) then return x
  let (typ, key) ← LeanProto.EncDec.decodeKey
  match key with
  | 1 => do CodeGeneratorRequest__deserializeAux (CodeGeneratorRequest.mk ((← LeanProto.EncDec.decodeKeyAndNonPackedArray ((LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeString) arbitrary) typ  (x.fileToGenerate))) (CodeGeneratorRequest.parameter x) (CodeGeneratorRequest.protoFile x) (CodeGeneratorRequest.compilerVersion x) )
  | 2 => do CodeGeneratorRequest__deserializeAux (CodeGeneratorRequest.mk (CodeGeneratorRequest.fileToGenerate x) ((← (LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeString) (x.parameter.getD arbitrary))) (CodeGeneratorRequest.protoFile x) (CodeGeneratorRequest.compilerVersion x) )
  | 15 => do CodeGeneratorRequest__deserializeAux (CodeGeneratorRequest.mk (CodeGeneratorRequest.fileToGenerate x) (CodeGeneratorRequest.parameter x) ((← LeanProto.EncDec.decodeKeyAndNonPackedArray ((fun v => LeanProto.EncDec.decodeMessage (google.protobuf.FileDescriptorProto__deserializeAux v)) arbitrary) typ  (x.protoFile))) (CodeGeneratorRequest.compilerVersion x) )
  | 3 => do CodeGeneratorRequest__deserializeAux (CodeGeneratorRequest.mk (CodeGeneratorRequest.fileToGenerate x) (CodeGeneratorRequest.parameter x) (CodeGeneratorRequest.protoFile x) ((← (fun v => LeanProto.EncDec.decodeMessage (Version__deserializeAux v)) (x.compilerVersion.getD arbitrary))) )
  | _ => do if (← LeanProto.EncDec.done) then throw $ IO.userError "EoF before unknown value"
            CodeGeneratorRequest__deserializeAux x


partial def CodeGeneratorResponse_File__serializeAux (x: ByteArray) : CodeGeneratorResponse_File -> ByteArray
| CodeGeneratorResponse_File.mk a0 a1 a2 a3 => do
  let mut res : ByteArray := Inhabited.default
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeString) 2 rfl 1) res a0
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeString) 2 rfl 2) res a1
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeString) 2 rfl 15) res a2
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeMessage (google.protobuf.GeneratedCodeInfo__serializeAux)) 2 rfl 16) res a3
  return res


partial def CodeGeneratorResponse_File__deserializeAux (x: CodeGeneratorResponse_File) : LeanProto.EncDec.ProtoParseM CodeGeneratorResponse_File := do
  if (← LeanProto.EncDec.done) then return x
  let (typ, key) ← LeanProto.EncDec.decodeKey
  match key with
  | 1 => do CodeGeneratorResponse_File__deserializeAux (CodeGeneratorResponse_File.mk ((← (LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeString) (x.name.getD arbitrary))) (CodeGeneratorResponse_File.insertionPoint x) (CodeGeneratorResponse_File.content x) (CodeGeneratorResponse_File.generatedCodeInfo x) )
  | 2 => do CodeGeneratorResponse_File__deserializeAux (CodeGeneratorResponse_File.mk (CodeGeneratorResponse_File.name x) ((← (LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeString) (x.insertionPoint.getD arbitrary))) (CodeGeneratorResponse_File.content x) (CodeGeneratorResponse_File.generatedCodeInfo x) )
  | 15 => do CodeGeneratorResponse_File__deserializeAux (CodeGeneratorResponse_File.mk (CodeGeneratorResponse_File.name x) (CodeGeneratorResponse_File.insertionPoint x) ((← (LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeString) (x.content.getD arbitrary))) (CodeGeneratorResponse_File.generatedCodeInfo x) )
  | 16 => do CodeGeneratorResponse_File__deserializeAux (CodeGeneratorResponse_File.mk (CodeGeneratorResponse_File.name x) (CodeGeneratorResponse_File.insertionPoint x) (CodeGeneratorResponse_File.content x) ((← (fun v => LeanProto.EncDec.decodeMessage (google.protobuf.GeneratedCodeInfo__deserializeAux v)) (x.generatedCodeInfo.getD arbitrary))) )
  | _ => do if (← LeanProto.EncDec.done) then throw $ IO.userError "EoF before unknown value"
            CodeGeneratorResponse_File__deserializeAux x

partial def CodeGeneratorResponse__serializeAux (x: ByteArray) : CodeGeneratorResponse -> ByteArray
| CodeGeneratorResponse.mk a0 a1 a2 => do
  let mut res : ByteArray := Inhabited.default
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeString) 2 rfl 1) res a0
  res := LeanProto.EncDec.encodeOpt (LeanProto.EncDec.encodeWithTag (LeanProto.EncDec.encodeNatAsUInt64) 0 rfl 2) res a1
  res := LeanProto.EncDec.encodeUnpackedArrayWithTag (LeanProto.EncDec.encodeMessage (CodeGeneratorResponse_File__serializeAux)) 2 rfl 15 res a2
  return res


partial def CodeGeneratorResponse__deserializeAux (x: CodeGeneratorResponse) : LeanProto.EncDec.ProtoParseM CodeGeneratorResponse := do
  if (← LeanProto.EncDec.done) then return x
  let (typ, key) ← LeanProto.EncDec.decodeKey
  match key with
  | 1 => do CodeGeneratorResponse__deserializeAux (CodeGeneratorResponse.mk ((← (LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeString) (x.error.getD arbitrary))) (CodeGeneratorResponse.supportedFeatures x) (CodeGeneratorResponse.file x) )
  | 2 => do CodeGeneratorResponse__deserializeAux (CodeGeneratorResponse.mk (CodeGeneratorResponse.error x) ((← (LeanProto.EncDec.withIgnoredState LeanProto.EncDec.decodeUInt64AsNat) (x.supportedFeatures.getD arbitrary))) (CodeGeneratorResponse.file x) )
  | 15 => do CodeGeneratorResponse__deserializeAux (CodeGeneratorResponse.mk (CodeGeneratorResponse.error x) (CodeGeneratorResponse.supportedFeatures x) ((← LeanProto.EncDec.decodeKeyAndNonPackedArray ((fun v => LeanProto.EncDec.decodeMessage (CodeGeneratorResponse_File__deserializeAux v)) arbitrary) typ  (x.file))) )
  | _ => do if (← LeanProto.EncDec.done) then throw $ IO.userError "EoF before unknown value"
            CodeGeneratorResponse__deserializeAux x


end

#eval "Defined encdec"

instance : LeanProto.ProtoSerialize Version where
  serialize b := Version__serializeAux (Inhabited.default) b

instance : LeanProto.ProtoDeserialize Version where
  deserialize (b: ByteArray) :=
    let res := LeanProto.EncDec.decode b (Version__deserializeAux Inhabited.default)
    LeanProto.EncDec.resultToExcept res

instance : LeanProto.ProtoSerialize CodeGeneratorRequest where
  serialize b := CodeGeneratorRequest__serializeAux (Inhabited.default) b

instance : LeanProto.ProtoDeserialize CodeGeneratorRequest where
  deserialize (b: ByteArray) :=
    let res := LeanProto.EncDec.decode b (CodeGeneratorRequest__deserializeAux Inhabited.default)
    LeanProto.EncDec.resultToExcept res

instance : LeanProto.ProtoSerialize CodeGeneratorResponse_File where
  serialize b := CodeGeneratorResponse_File__serializeAux (Inhabited.default) b

instance : LeanProto.ProtoDeserialize CodeGeneratorResponse_File where
  deserialize (b: ByteArray) :=
    let res := LeanProto.EncDec.decode b (CodeGeneratorResponse_File__deserializeAux Inhabited.default)
    LeanProto.EncDec.resultToExcept res

instance : LeanProto.ProtoSerialize CodeGeneratorResponse where
  serialize b := CodeGeneratorResponse__serializeAux (Inhabited.default) b

instance : LeanProto.ProtoDeserialize CodeGeneratorResponse where
  deserialize (b: ByteArray) :=
    let res := LeanProto.EncDec.decode b (CodeGeneratorResponse__deserializeAux Inhabited.default)
    LeanProto.EncDec.resultToExcept res

#eval "Defined instances"

end compiler
end protobuf
end google

